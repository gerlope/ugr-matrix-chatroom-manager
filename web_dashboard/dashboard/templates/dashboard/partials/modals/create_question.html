<div 
  x-show="$store.modal.createQuestionModal" 
  class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
  x-transition.opacity
  x-data="{
    qtype: '{{ create_question_form.qtype.value|default:'multiple_choice' }}',
    options: JSON.parse('{{ create_question_options_json|default:'[]'|escapejs }}')
  }"
  @keydown.escape.window="$store.modal.createQuestionModal = false"
  @click.self="$store.modal.createQuestionModal = false"
>
  <div class="bg-white rounded-lg shadow-lg w-11/12 max-w-2xl p-6 relative" @click.stop x-transition.opacity>
    <h3 class="text-lg font-semibold mb-4">Crear nueva pregunta</h3>

    {% if create_question_form and create_question_form.non_field_errors %}
      <div class="mb-4 p-2 bg-red-100 text-red-700 rounded">
        {% for error in create_question_form.non_field_errors %}
          <p>{{ error }}</p>
        {% endfor %}
      </div>
    {% endif %}

  <form id="create_question_form" method="POST" action="{% url 'dashboard:create_question' %}">
      {% csrf_token %}
      <input type="hidden" name="selected_room_id" value="{{ selected_room.id|default:'' }}">

      <div class="mb-3">
        <label class="block mb-1 font-medium">Título</label>
        <input type="text" name="title" required class="w-full border rounded px-3 py-2" value="{{ create_question_form.title.value|default_if_none:'' }}">
      </div>

      <div class="mb-3">
        <label class="block mb-1 font-medium">Enunciado</label>
        <textarea name="body" required class="w-full border rounded px-3 py-2" rows="3">{{ create_question_form.body.value|default_if_none:'' }}</textarea>
      </div>

      <div class="mb-3">
        <label class="block mb-1 font-medium">Tipo de pregunta</label>
          <select name="qtype" x-model="qtype" class="w-full border rounded px-3 py-2">
          <option value="multiple_choice" {% if create_question_form and create_question_form.qtype.value == 'multiple_choice' %}selected{% endif %}>Opción múltiple</option>
          <option value="poll" {% if create_question_form and create_question_form.qtype.value == 'poll' %}selected{% endif %}>Encuesta</option>
          <option value="true_false" {% if create_question_form and create_question_form.qtype.value == 'true_false' %}selected{% endif %}>Verdadero/Falso</option>
          <option value="short_answer" {% if create_question_form and create_question_form.qtype.value == 'short_answer' %}selected{% endif %}>Respuesta corta</option>
          <option value="numeric" {% if create_question_form and create_question_form.qtype.value == 'numeric' %}selected{% endif %}>Numérica</option>
          <option value="essay" {% if create_question_form and create_question_form.qtype.value == 'essay' %}selected{% endif %}>Desarrollo</option>
        </select>
      </div>
      <div x-show="qtype == 'multiple_choice' || qtype == 'poll'" class="mb-3" x-data="{ opts: options, corrects: (options && options.length) ? options.map(() => false) : [], allow_multi: false, single_correct_index: null }">
          <label class="block mb-1 font-medium">Opciones</label>

          <div class="mb-2 flex items-center space-x-4">
            <label class="flex items-center space-x-2">
              <input type="checkbox" x-model="allow_multi" class="rounded" />
              <span class="text-sm text-gray-700">Permitir varias respuestas</span>
            </label>
            <div class="text-sm text-gray-500">Elige si la pregunta permite una única respuesta correcta o varias.</div>
          </div>

          <template x-for="(opt, idx) in opts" :key="idx">
            <div class="flex items-center space-x-2 mb-2">
              <input :name="`option_${idx}`" x-model="opts[idx]" class="flex-1 border rounded px-3 py-2" placeholder="Texto de la opción">

              <!-- Show correct-choice controls only for actual multiple_choice (not for poll) -->
              <div x-show="qtype == 'multiple_choice'">
                <label class="flex items-center space-x-2" x-show="allow_multi">
                  <input type="checkbox" :name="`option_correct_${idx}`" x-model="corrects[idx]" class="rounded" />
                  <span class="text-sm text-gray-600">Correcta</span>
                </label>
                <label class="flex items-center space-x-2" x-show="!allow_multi">
                  <input type="radio" name="option_correct_single" :value="idx" x-model="single_correct_index" class="rounded" />
                  <span class="text-sm text-gray-600">Correcta</span>
                </label>
              </div>

              <button type="button" @click="opts.splice(idx,1); corrects.splice(idx,1)" class="px-2 py-1 bg-red-600 text-white rounded">Eliminar</button>
            </div>
          </template>

          <div class="flex space-x-2">
            <button type="button" @click="opts.push(''); corrects.push(false)" class="px-3 py-1 bg-blue-600 text-white rounded">Añadir opción</button>
            <div class="text-sm text-gray-500 self-center">Añade opciones y marca la(s) correcta(s) antes de crear.</div>
          </div>

          <template x-if="qtype == 'poll'">
            <p class="text-sm text-gray-500 mt-2">Encuesta: no hay respuestas correctas, las opciones servirán sólo para recoger votos.</p>
          </template>

          <template x-for="(opt, idx) in opts" :key="'hidden-'+idx">
            <input type="hidden" :name="`option_${idx}`" :value="opt">
          </template>

          <!-- submit allow_multiple flag as a hidden field (checkbox semantics: present when true) -->
          <input type="hidden" name="allow_multiple_selections" :value="allow_multi ? 'on' : ''">
        </div>
      </template>

      <template x-if="qtype == 'true_false'">
        <div class="mb-3" x-data="{ tf_choice: '0' }">
          <label class="block mb-1 font-medium">Verdadero / Falso (selecciona la correcta)</label>
          <div class="flex items-center space-x-4 mb-2">
            <label class="flex items-center space-x-2">
              <input type="radio" name="tf_correct" value="0" x-model="tf_choice" class="rounded" />
              <span>Verdadero</span>
            </label>
            <label class="flex items-center space-x-2">
              <input type="radio" name="tf_correct" value="1" x-model="tf_choice" class="rounded" />
              <span>Falso</span>
            </label>
          </div>
          <!-- Hidden option texts to be consumed by backend -->
          <input type="hidden" name="option_0" value="Verdadero">
          <input type="hidden" name="option_1" value="Falso">
        </div>
      </template>

      <template x-if="qtype == 'short_answer' || qtype == 'numeric'">
        <div class="mb-3">
          <label class="block mb-1 font-medium">Respuesta esperada</label>
          <input type="text" name="expected_answer" class="w-full border rounded px-3 py-2" placeholder="Texto o valor con el que comparar">
          <p class="text-sm text-gray-500 mt-1">Esta respuesta se usará para comparar envíos cortos o numéricos (comparación exacta por ahora).</p>
        </div>
      </template>

      <div class="mb-3 grid grid-cols-2 gap-3">
        <div>
          <label class="block mb-1 font-medium">Inicio</label>
          <input id="question_start_at" type="datetime-local" name="start_at" class="w-full border rounded px-3 py-2" value="{{ create_question_form.start_at.value|default_if_none:'' }}">
        </div>
        <div>
          <label class="block mb-1 font-medium">Fin</label>
          <input id="question_end_at" type="datetime-local" name="end_at" class="w-full border rounded px-3 py-2" value="{{ create_question_form.end_at.value|default_if_none:'' }}">
        </div>
      </div>

      <p id="question_time_error" class="text-red-600 text-sm mb-3 hidden"></p>
  <p id="question_options_error" class="text-red-600 text-sm mb-3 hidden"></p>

      <div class="mb-4 space-y-2">
        <label class="flex items-center space-x-2"><input type="checkbox" name="allow_multiple_submissions" class="rounded" {% if create_question_form.allow_multiple_submissions.value %}checked{% endif %}> Permitir varios envíos por alumno</label>
        <template x-if="qtype != 'essay' && qtype != 'poll'">
          <label class="flex items-center space-x-2"><input type="checkbox" name="close_on_first_correct" class="rounded" {% if create_question_form.close_on_first_correct.value %}checked{% endif %}> Cerrar tras la primera respuesta correcta</label>
        </template>
      </div>

      <div class="flex justify-end space-x-2">
        <button type="button" @click="$store.modal.createQuestionModal = false" class="px-4 py-2 border rounded hover:bg-gray-100">Cancelar</button>
        <button type="submit" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">Crear pregunta</button>
      </div>
    </form>
  </div>
</div>

<script>
  (function(){
    const form = document.getElementById('create_question_form');
    if (!form) return;
    const st = document.getElementById('question_start_at');
    const et = document.getElementById('question_end_at');
    const err = document.getElementById('question_time_error');

    function showError(msg){ if (err) { err.textContent = msg; err.classList.remove('hidden'); } }
    function hideError(){ if (err) { err.textContent = ''; err.classList.add('hidden'); } }

    form.addEventListener('submit', function(ev){
      hideError();
      // options validation for multiple_choice
      try {
        const qtypeEl = form.querySelector('select[name="qtype"]');
        const qtypeVal = qtypeEl ? qtypeEl.value : null;
        if (qtypeVal === 'multiple_choice') {
          const singleChecked = form.querySelector('input[name="option_correct_single"]:checked');
          const multiChecked = form.querySelectorAll('input[name^="option_correct_"]:checked');
          if (!singleChecked && (!multiChecked || multiChecked.length === 0)) {
            const optErr = document.getElementById('question_options_error');
            if (optErr) { optErr.textContent = 'Debes marcar al menos una opción correcta.'; optErr.classList.remove('hidden'); }
            ev.preventDefault();
            return;
          }
        }
      } catch(e){ console.error(e); }
      const s = st && st.value ? new Date(st.value) : null;
      const e = et && et.value ? new Date(et.value) : null;
      if (s && e && s >= e){ showError('La hora de inicio debe ser anterior a la hora de fin.'); ev.preventDefault(); return; }
      // allow submit
    });
  })();
</script>
